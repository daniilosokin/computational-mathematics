# Вычислительная математика. Лабораторная работа №2 

## Решение систем линейных уравнений

Везде далее рассматриваем решение системы линейных уравнений вида:

$$
\begin{cases} 
a_{11}x_{1} + a_{12}x_{2} + \dots + a_{1n}x_{n} = b_{1} 
\\ 
a_{21}x_{1} + a_{22}x_{2} + \dots + a_{2n}x_{n} = b_{2} 
\\
\dots
\\
a_{1n}x_{1} + a_{2n}x_{2} + \dots + a_{nn}x_{n} = b_{n}
\end{cases}
$$

или в матричном виде: $AX=B$, где на матрицу $А$ будем накладывать
определенные условия.

Из курса линейной алгебры вам известны методы точного нахождения
решения системы: метод Крамера, метод Гаусса, метод обратной
матрицы.

В большинстве случаев решение линейной системы уравнений «руками»
представляет определенные вычислительные сложности и становится
труднореализуемо при большом количестве неизвестных. В данном курсе вы
познакомитесь с численными методами решения линейных систем.

### Срезы матриц

Первым делом познакомимся с различными программными реализациями
умножения векторов и матриц. В NumPy матрица реализована
как двумерный массив `ndarray`, который является многомерным однородным
массивом с заранее заданным количеством элементов. Однородный —
потому что практически все объекты в нем одного размера или типа.
Количество размерностей и объектов массива определяются его
размерностью (`shape`), кортежем $N$-положительных целых чисел. Они
указывают размер каждой размерности. Размерности определяются как оси.
Размер массивов NumPy фиксирован, а это значит, что после создания
объекта его уже нельзя поменять. Это поведение отличается от такового у
списков Python, которые могут увеличиваться и уменьшаться в размерах.

При работе с индексами массивов всегда используются квадратные скобки
(`[`, `]`). С помощью индексирования можно ссылаться на отдельные элементы,
выделяя их или даже меняя значения. При создании нового массива шкала с
индексами создается автоматически.

|       |        |        |        |        |        |        |
| ---   | ---    | ---    | ---    | ---    | ---    | ---    |
|       | `[0]`  | `[1]`  | `[2]`  | `[3]`  | `[4]`  | `[5]`  |
| **a** | 10     | 11     | 12     | 13     | 14     | 15     |
|       | `[-6]` | `[-5]` | `[-4]` | `[-3]` | `[-2]` | `[-1]` |

Для получения доступа к одному элементу на него нужно сослаться через его
индекс:

```Python
>>> a = np.arrange(10, 16)
>>> a
array([10, 11, 12, 13, 14, 15])
>>> a[4]
14
```

Для выбора нескольких элементов в квадратных скобках можно передать
массив индексов.

Двухмерные массивы, матрицы, представлены в виде прямоугольного
массива, состоящего из строк и колонок, определенных двумя осями, где ось
0 представлена строками, а ось 1 — колонками. Таким образом, индексация
происходит через пару значений; первое — это значение ряда, а второе —
колонки. И если нужно получить доступ к определенному элементу матрицы,
необходимо все еще использовать квадратные скобки, но уже с двумя
значениями.

В зависимости от части массива, которую необходимо извлечь, нужно
использовать синтаксис среза; это последовательность числовых значений,
разделенная двоеточием (`:`) в квадратных скобках.

Чтобы лучше понять синтаксис среза, необходимо рассматривать и случаи,
когда явные числовые значения не используются. Если не ввести первое
число, NumPy неявно интерпретирует его как 0 (то есть, первый элемент
массива). Если пропустить второй — он будет заменен на максимальный
индекс, а если последний — представлен как 1. То есть, все элементы будут
перебираться без интервалов

```Python
>>> a[::2]
array([10, 12, 14])
>>> a[:5:2]
array([10, 12, 14])
>>> a[:5:]
array([10, 11, 12, 13, 14]
```

В случае с двухмерными массивами срезы тоже работают, но их нужно
определять отдельно для рядов и колонок. Например, если нужно получить
только первую строку:

```python
array([[10, 11, 12],
[13, 14, 15],
[16, 17, 18]])
>>> A[0,:]
array([10, 11, 12])
```

Как видно по второму индексу, если оставить только двоеточие без числа,
будут выбраны все колонки. А если нужно выбрать все значения первой
колонки, то необходимо писать обратное.

```Python
>>> A[:,0]
array([10, 13, 16])
```

Если же необходимо извлечь матрицу меньшего размера, то нужно явно
указать все интервалы с соответствующими индексами.

### Умножение матриц

Операция умножения матриц вам хорошо известна из курса линейной
алгебры. Умножение матрицы $А$ на матрицу $В$ возможно только в случае,
когда количество столбцов матрицы $А$ совпадает с количеством строк
матрицы $В$. Элемент $c_{ij}$ новой матрицы получается как умножение $i$-той
строки матрицы $A$ на $j$-тый столбец матрицы $В$.

Возможно несколько реализаций матричного умножения: в скалярном виде, в
векторном и в матричном.

Скалярный вид: 
$c_{ij}=\sum_{t=1}^{k}a_{ij}b_{ij},1<=i<=n,1<=j<=m$, 
где матрица $А$ имеет размер ${n}\times{k}$, 
матрица $B$ имеет размер ${k}\times{m}$.

Алгоритм умножения матриц в скалярном виде (поэлементный):

```Python
n = 3
k = 4
m = 5

A = np.random.randint(0, 11, (n, k))
B = np.random.randint(0, 11, (k, m))
C = np.zeros((n, m), dtype = int)

for i in range(n):
	for j in range(m):
		for i in range(k):
			C[i, j] = C[i, j] + A[i, p] * B[p, j]

```

Однако такое решение является достаточно медленным.

Векторные операции существенно увеличивают скорость вычислений.

Алгоритм умножения матриц в векторном виде позволяет сразу находить
произведение $i$-той строки матрицы $А$ на $j$-тый столбец матрицы $В$.

Векторный вид: $c_{ij}={A(i,:)}\cdot{B(:,j)},1<=i<=n,1<=j<=m$

в этом случае операция умножения – это уже скалярное
умножение из модуля NumPy (`np.dot`).

Мы можем использовать также матричное умножение. В нашем случае будем
«собирать» матрицу $С$ по строкам (для нахождения $i$-той строки матрицы $С$
умножим $i$-тую строку матрицы $А$ на матрицу $B$).

Матричный вид: $C(i,:)={A(i,:)}\cdot{B}$

Можно также «собрать» матрицу $С$ по столбцам.

### Решение треугольных систем линейных уравнений.

Вернемся к решению начальной системы. Наиболее просто она решается, когда
матрица А приведена к треугольному виду с единицами по главной
диагонали (к унитреугольному виду). Напомню, что матрицу $А$ всегда можно
привести к подобному виду, если определитель матрицы $А$ не равен 0.

$$
\begin{pmatrix}
1 & 0 & \dots & 0 \\
a_{21} & 1 & \dots & 0 \\
 &  & \dots & \\
a_{n1} & a_{n1} & \dots & 1
\end{pmatrix}
\begin{pmatrix}
x_{1} \\
x_{2} \\
\vdots \\
x_{n}
\end{pmatrix}
= \begin{pmatrix}
b_{1} \\
b_{2} \\
\vdots \\
b_{n}
\end{pmatrix}
$$

Решение системы прямой подстановкой:

$$
\begin{cases}
x_{1} = b_{1} \\ 
x_{2} = b_{2} - a_{21}x_{1} \\
\dots \\
x_{i} = b_{i}-\sum_{k=1}^{i-1}a_{ik}x_{k}
\end{cases}
$$

Алгоритм решения в векторном виде:

```Python

A = np.array([[1, 0, 0], [3, 1, 0], [-4, 5, 1]], int) # Матрица (левая часть системы)
B = пр.аггау([2, 4, 3], int) # Вектор (правая часть системы)
X = np.zeros((3,1), int)

x[0] = B[0]

for i in range(1,3):
	x[i] = B[i] - пp.dot (A[i, :i], x[:i])


```

В цикле умножаем элементы $i$-той строки матрицы $А$ до главной диагонали
на часть вектора $x$.

Также возможно решение без введения переменной х, хранящей решение
системы.

### Приведение матрицу А к LU виду.

$LU$-разложение – это представление матрицы $А$ в виде произведения двух
матриц: $L$ – нижняя унитреугольная, $U$ – верхняя треугольная. $LU$-
разложение используется для решения систем линейных уравнений,
обращения матриц и вычисления определителя. $LU$-разложение существует
только в том случае, когда матрица $A$ обратима (невырождена), и все
ведущие (угловые) главные миноры матрицы $A$ невырождены.

Допустим, нам удалось найти матрицы $L$ и $U$ такие, что $A=LU$. Очевидно,
это возможно только в случае невырожденной матрицы $A$.
Тогда $a_{11}={l_{11}}\cdot{u_{11}}.

Предположим, что $a_{11}=0$, но тогда $l_{11}=0$ или $u_{11}=0$, что означает
равенство нулю первой строки матрицы L или первого столбца матрицы U, из чего
следует их вырожденность.

Итак, далее считаем, что ${a_{11}}\neq{0}$. Представим матрицу $A$ как блочную
матрицу: 

$$
A =
\begin{pmatrix}
a_{11} & w \\
v & A^{'}
\end{pmatrix}
$$

где $w$ – вектор-строка $w=(a_{12},\dots,a_{1n})$ размера ${1}\cdot{(n-1)}$,
$v$ – вектор-столбец 

$$
v =
\begin{pmatrix}
a_{21} \\
\vdots \\
a_{n1}
\end{pmatrix}
$$

размера ${(n-1)}\cdot{1}$, $A^{'}$ - матрица (минор) размера
${(n-1)}\cdot{(n-1)}$. Аналогичным образом представим матрицы $L$ и $U$:

$$
L =
\begin{pmatrix}
1 & 0 \\
v_{L} & L^{'}
\end{pmatrix}
\text{,  } U =
\begin{pmatrix}
a_{11} & w_{U} \\
0 & U^{'}
\end{pmatrix}
$$

Тогда:

$$
A = LU = \begin{pmatrix}
1 & 0
\\
v_{L} & L^{'}
\end{pmatrix}
\cdot
\begin{pmatrix}
a_{11} & w_{U}
\\
0 & U^{'}
\end{pmatrix}
 = \begin{pmatrix}
a_{11} & w_{U}
\\
{v_{L}}\cdot{a_{11}} & {v_{L}}\cdot{w_{U}}+{L^{'}}\cdot{U^{'}}
\end{pmatrix}
 = \begin{pmatrix}
a_{11} & w
\\
v & A^{'}
\end{pmatrix}
$$

Заметим, что умножение ${v_{L}}\cdot{w_{U}}$ - это умножение столбца размера
${(n-1)}\cdot{1}$ на строку размера  ${1}\cdot{(n-1)}$, что влечет получение
матрицы размера ${(n-1)}\cdot{(n-1)}$.

Итак, получили формулы нахождения матриц $L$ и $U$:

$$
\begin{pmatrix}
w_{U} = w
\\
w_{L} = \frac{v}{a_{11}}
\\
{L^{'}}\cdot{U^{'}} = A^{'} - \frac{{v}\cdot{w}}{a_{11}} 
\end{pmatrix}
$$

Итак, нахождение $LU$ разложения для матрицы $А$ сведено к нахождению $LU$-
разложения для матрицы ${L^{'}}\cdot{U^{'}}$ размера ${(n-1)}\cdot{(n-1)}$.

Выражение $A^{'}-\frac{{v}\cdot{w}}{a_{11}}$ называется дополнением Шура
элемента $a_{11}$ в матрице $А$.

Приведем алгоритм нахождения $LU$–разложения:

```Python

U = np.zeros((n, n), float)
L = np.identity(n, float)

for i in range(n):
	for j in range(n):
		if i<=j:
			U[i, j] = A1[i, j] - np.dot(L[i, :i], U[:i, j])
		if i>j:
			U[i, j] = (A1[i, j] - np.dot(L[i, :j], U[:j, j])) / U[j, j]


```

### Применение LU-разложения

#### Решение систем линейных уравнений

Полученное $LU$-разложение матрицы $A$ (матрица коэффициентов системы)
может быть использовано для решения семейства систем линейных
уравнений с различными векторами $b$ в правой части:

$$
Ax=b
$$

Если известно $LU$-разложение матрицы $A=LU$, исходная система может быть
записана как:

$$
LUx=b
$$

Эта система может быть решена в два шага. На первом шаге решается
система

$$
Ly=b
$$

Поскольку $L$ — нижняя треугольная матрица, эта система решается
непосредственно прямой подстановкой.

На втором шаге решается система

$$
Ux=y
$$

Поскольку $U$ — верхняя треугольная матрица, эта система решается
непосредственно обратной подстановкой.

#### Обращение матриц

Обращение матрицы $A$ эквивалентно решению линейной системы

$$
AX=E
$$

где $X$ — неизвестная матрица, $E$ — единичная матрица. Решение $X$ этой
системы является обратной матрицей $A^{-1}$.

Систему можно решить описанным выше методом $LU$-разложения.

Вычисление определителя матрицы

Имея $LU$-разложение матрицы $A=LU$,
можно непосредственно вычислить еѐ определитель

$$
det(A)=det(LU)=det(L)det(U)={l_{11}}\cdot{...}\cdot{l_{nn}}\cdot{u_{11}}\cdot{...}\cdot{u_{nn}}
$$

## Рекомендации по выполнению лабораторной работы.

В 3 задании рекомендуется использовать функции `np.tril` и `np.triu` для создания треугольных матриц.

`numpy.tril(m, k=0)` – возвращает копию массива `m`, с элементами
выше 'k'-той диагонали равными нулю. По умолчанию $k=0$ (главная
диагональ), $k<0$ диагональ ниже главной, $k>0$ диагональ выше
главной диагонали.


В 3 задании для решения использовать или алгоритм прямой
подстановки, приведенной в исходном файле, или разработать свой
алгоритм прямой подстановки для верхнетреугольной матрицы и
для не унитреугольной матрицы.

Функцию `solve` использовать для проверки своего решения.

В 4 задании обязательно отдельно выводить матрицы $L$ и $U$, а
также проверить правильность их нахождения.

В 4 задании рекомендуется выполнить следующие действия:
- Ввести свои данные
- Найти для матрицы $А$ $LU$-разложение.
- Проверить правильность полученного $LU$-разложения
- Решить систему $L(UX)=B$ , где $UX$ положить за неизвестный
вектор $Y$ (то есть решить систему $LY=B$) методом прямой
подстановки.
- Решить систему $UX=Y$ собственным разработанным
алгоритмом.
- Проверить функцией `solve` найденный вектор $X$.

## Задание

**Вариант №19:**

1. Создать квадратную матрицу из случайных вещественных чисел из интервала $(-1,1)$ размера $8$. Найти скалярное произведение 1 строки на 8 столбец. Использовать срезы матриц.

2. Создать две матрицы из случайных целых чисел из $[-6,6]$ подходящего размера. 
Найти их произведение тремя способами: 
- Cкалярный алгоритм умножения матриц 
- Векторный алгоритм, 
- Проверив с помощью функции `np.dot`.

3. Создать произвольную нижнюю унитреугольную матрицу $А$ 7 порядка, 
вектор $B$ произвольный. Решить систему $АХ=В$.

4. Решить систему, используя $LU$ разложение

$$
\begin{cases}
1.7 х_{1} - 1.8 х_{2} + 1.9 х_{3} - 57.4 х_{4} = 10 \\
1.1 х_{1} - 4.3 х_{2} + 1.5 х_{3} - 1.7  х_{4} = 19 \\
1.2 х_{1} + 1.4 х_{2} + 1.6 х_{3} + 1.8  х_{4} = 20 \\
7.1 х_{1} - 1.3 х_{2} - 4.1 х_{3} + 5.2  х_{4} = 10
\end{cases}
$$
